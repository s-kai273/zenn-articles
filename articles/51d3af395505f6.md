---
title: "VSCodeVimのアーキテクチャを解説してみた"
emoji: "💭"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

## はじめに

## アーキテクチャ概要

今回は基本的なキー入力からエディタに実際に反映されるところまでを解説します。  
VSCodeVim はキーバインディングによる処理をサポートするため、入力されたキーを一つずつ処理し、リアルタイムに状態管理やエディタの内容の修正を行う必要があります。  
それを実現する大まかな流れは下記です。

1. キー入力のハンドリング
2. キーから Action の取得
3. Action の実行
4. Transformation の実行

これらについて、それぞれ詳しく見ていきたいと思います。

## キー入力のハンドリング

ここが処理系のエントリポイントになります。  
まずキー入力のハンドリングをする上で考えてもらいたいのが、このプラグインを有効にしていない状態で修飾キー以外の文字を入力すると、その内容がエディタ上に入力されます。  
例えば「i」というキーを入力すれば、当たり前ですが、エディタ上では「i」という文字が入力されるわけです。

一方 Vim のキーバインディングならどうなるのか？  
「i」という文字を入力してもそれがエディタ上に入力されるのかは、現在のモードによります。  
例えば Normal モード中の入力なら Insert モードに切り替わりますし、Insert モード中の入力なら「i」がエディタ上に入力されるはずです。

ここからわかることとして、Vim のキーバインディングでは一つのキーを入力してもそれによる挙動はモードによって異なりますし、とりあえずエディタのコンテンツに強制的にその文字を入力するデフォルト挙動は都合が悪いです。

なので VSCodeVim ではデフォルト挙動を本プラグイン専用の処理に上書きしています。  
文字の入力の仕方で発火するコマンドが異なるため、実際は複数のコマンドを上書きしていますが、代表的なコードは下記です。

```
// extensionBase.ts
  overrideCommand(context, 'type', async (args: { text: string }) => {
    taskQueue.enqueueTask(async () => {
      const mh = await getAndUpdateModeHandler();
      if (mh) {
        if (compositionState.isInComposition) {
          compositionState.composingText += args.text;
          if (mh.vimState.currentMode === Mode.Insert) {
            compositionState.insertedText = true;
            void vscode.commands.executeCommand('default:type', { text: args.text });
          }
        } else {
          await mh.handleKeyEvent(args.text);
        }
      }
    });
  });
```

さて、このコードを見た時にいくつか分岐はありますが、ほとんどのケースでやっていることは `ModeHandler` 型のオブジェクトの `mh` に処理を処理しているということです。  
`if (compositionState.isInComposition)` のケースは IME などを使っている少し特殊なケースなので、基本形の処理は `await mh.handleKeyEvent(args.text);` で行われています。  
こちらの処理をさらに見ていきましょう。

## キーから Action の取得

`ModeHandler` の `handleKeyEvent` メソッドで行っていることはいくつかありますが、まず最初に行っているのはキーを Action に変換することです。  
ここで Action とは何かを簡単に解説しておきます。

Action とは一言でいうと、一つのキー入力から割り当てられる Vim の処理単位のことです。  
具体例として Insert モードで文字入力をする例を考えてみましょう。  
ここでは、Normal モードから Insert モードに入り「abc」という文字を入力し Esc キーで Normal モードに戻る動作を行うとします。  
ここでの実際のキー入力は「iabc<Esc>」となるはずですが、それぞれ次の Action に変換されます。

- i: CommandInsertAtCursor
- a: CommandInsertInInsertMode
- b: CommandInsertInInsertMode
- c: CommandInsertInInsertMode
- <Esc>: CommandEscInsertMode

それぞれの処理としては、

- CommandInsertAtCursor: Insert モードに入る処理
- CommandInsertInInsertMode: Insert モード中に文字を入力する処理
- CommandEscInsertMode: Insert モードから Normal モードに戻る処理

そして各 Action には実際にそれぞれの処理を実現するためのコードが記載されています。

さて、ここでキーから Action を取得する話しに戻りますが、具体的には `ModeHandler` の `handleKeyAsAnAction` メソッド内部の `getRelevantAction` メソッドで取得しています。

```
// src/mode/modeHandler.ts
  private async handleKeyAsAnAction(key: string): Promise<boolean> {
    if (vscode.window.activeTextEditor !== this.vimState.editor) {
      Logger.warn('Current window is not active');
      return false;
    }

    // Catch any text change not triggered by us (example: tab completion).
    this.vimState.historyTracker.addChange();

    const recordedState = this.vimState.recordedState;
    recordedState.actionKeys.push(key);
    void VSCodeContext.set('vim.command', recordedState.commandString);

    const action = getRelevantAction(recordedState.actionKeys, this.vimState);
    // 省略
  }
```

`getRelavantAction` メソッドの第一引数で入力されたキー情報、第二引数で状態管理のオブジェクトである `vimState` が渡されており、この 2 つの情報から対応する Action を決定しています。

## Action の実行

決定された Action から実際にその Action の実行へと移っていきます。  
具体的には同じく `ModeHandler` の `handleKeyAsAnAction` メソッド内部の `runAction` メソッドから実行されます。  
ここでは `runAction` の詳細を見るよりも呼び出される Action の定義を詳しく見ていきたいと思っています。

ここでは先程の `CommandInsertAtCursor` を例として取り上げます。

```
// src/actions/commands/action.ts
@RegisterAction
export class CommandInsertAtCursor extends BaseCommand {
  modes = [Mode.Normal];
  keys = [['i'], ['<Insert>']];

  public override async exec(position: Position, vimState: VimState): Promise<void> {
    await vimState.setCurrentMode(Mode.Insert);
  }

  // 省略
}
```

Action のクラスの実装の大きな特徴として下記があります。

- `RegisterAction` デコレータが付与  
  これにより上記の `getRelevantAction` でキーから取得する Action の対象となります。
- `modes` と `keys` フィールドを保持  
  `getRelevantAction` で選択される Action の条件定義。
- `exec` メソッド  
  Action の実行処理内容。

よって選択された Action によって実行される実際の内容は `exec` メソッドに定義されていることになります。  
ここで大まかに分けるとこのメソッドで実行される内容は下記の 2 種類です。

1. 状態の更新
2. Transformation の登録

上記のコードでは `await vimState.setCurrentMode(Mode.Insert)` が 1 の状態の更新に当たります。
具体的には Normal モードから Insert モードへの切り替え処理です。

2 の Transformation の登録について説明する前に、まず Transformation とは何かを解説したいと思います。

Transformation は実際のテキストの更新を処理を以上するためのオブジェクトです。

は `CommandInsertAtCursor` では行っていないため 別のコードを見ていきます。

`CommandInsertInInsertMode` を代わりに見ていきます。

```
@RegisterAction
export class CommandInsertInInsertMode extends BaseCommand {
  modes = [Mode.Insert];
  keys = ['<character>'];

  public override async exec(position: Position, vimState: VimState): Promise<void> {
    const char = this.keysPressed.at(-1)!;

    let text = char;

    // 省略

    vimState.recordedState.transformer.addTransformation({
      type: 'insertTextVSCode',
      text,
      isMultiCursor: vimState.isMultiCursor,
    });
  }

  // 省略
}
```

このコードでは `vimState.recordedState.transformer.addTransformation` を呼び出し `insertTextVSCode` の Transformation を登録しています。  
この Transformation は

## おわりに
